/* LIBABC: approximate Bayesian Computation
 * Copyright (C) 2019  David J. Warne
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "mcl.h"
#include <time.h>

/* Moment Matching SMC ABC inference using the Fisher-KPP model 
 * for the approximate model and final target of the the hexagonal lattice model 
 * with a generalised proliferation function of Jin et al. (2016) Phys. Biol. 
 * using cell density profiles.
 */

ABC_Parameters aabc_p; /* for the continuum model*/
ABC_Parameters abc_p;  /* for the discrete model*/
SMC_Parameters smc_p;  /* SMC parameters */

/* data set structure */
Dataset data;

/* size of verticle axis in hex grid to average over*/
int I;

/**
 * @brief Discrepency metric
 * @details Computes the discrepancy measure \rho(D,D_s) used for ABC inference.
 *          For the scratch assay model the Frobenius distance is used.
 *
 * @param data      pointer to data used for inference
 * @param data_s    pointer to simulated data generated by forward model
 * 
 * @return the descrepancy measure for thresholding in ABC
 */
double 
rho(Dataset *data, Dataset *data_s)
{
    double *C,*C_s;
    double d;
    unsigned int nt,nx;
    
    C_s = (double *)data_s->fields[3].data_array;
    C = (double *)data->fields[3].data_array;

    nt = (unsigned int)data->fields[3].numRows;
    nx = (unsigned int)data->fields[3].numCols;

    d = 0;
    for (unsigned int i=0;i<nt*nx;i++)
    {
        d += (C[i] - C_s[i])*(C[i] - C_s[i]);
    }
    return sqrt(d);
}

/**
 * @brief prior sampler 
 * @details Generates a number of i.i.d. samples from p(D,\lambda,K)
 *
 * @param dim       dimensionality of parameter space 
 * @param nsamples  number of i.i.d. samplesto generate
 * @param support   pointer to array of 2*dim elements containing support limits
 * @param theta     pointer to nsamples*dim array to store samples.
 */
int 
prior(unsigned int dim, unsigned int nsamples, double* support,double * theta)
{
    unsigned int i,j;
    for (i=0;i<nsamples;i++)
    {
        for (int j=0;j<dim;j++)
        {
            theta[i*dim+j] = durngus(support[j],support[j+dim]); // lambda 
        }
    }
    return 0;
}

/**
 * @brief prior probability density function
 * @details evaluates the prior density pointwise
 *
 * @param dim   dimensionality of parameter space
 * @param theta pointer to point to evaluate the PDF at
 *
 * @returns the value of the prior density at theta
 */
double
priorPDF(unsigned int dim, double *theta)
{
    unsigned char tf;
    double p_inv;
    tf = 1; 
    p_inv = 1.0;
    for (int j=0;j<dim;j++)
    {
        tf = tf && (theta[j] >= abc_p.support[j]) && (theta[j] <= abc_p.support[j+dim]);
        p_inv *= (abc_p.support[j+dim] - abc_p.support[j]);
    }
    return (tf) ? 1.0/p_inv : 0.0;
}

#define SCALE 2.0

/**
 * @brief Adaptive updates too proposal kernel parameters
 * @details Uses particle population at step t-1 to compute parameters for
 *           proposal kernels use at step t. In this example, for Gaussian 
 *           proposals, we take the proposal covariance to be twice the particle
 *           covariance at t-1.
 *
 * @param N         the number of particles
 * @param dim       dimensionality if parameter space
 * @param theta     particles from SMC step t-1
 * @param weights   particle weights from step t-1
 * @param L         pointer to store kernel parameter values. In this case it is 
 *                  a dim*dim array to store the lower triangular matrix from 
 *                  the Cholesky factorization of the covariance matrix.
 */
int
adapt_kernel(unsigned int N, unsigned int dim, double * theta, double *weights, 
             double *L)
{
    double mu[dim], weight_bar;
    unsigned int i,j,k;
    for (k=0;k<dim;k++)
    {
        mu[k] = 0.0;
    }
    weight_bar = 0;
    for (k=0;k<dim*dim;k++)
    {
        L[k] = 0.0;
    }

    /* compute weighted mean*/
    for (i=0;i<N;i++)
    {
        for (k=0;k<dim;k++)
        {
            mu[k] += weights[i]*theta[i*dim + k];
        }
        weight_bar += weights[i];
    }
    for (k=0;k<dim;k++)
    {
        mu[k] /= weight_bar;
    }

    /* unbiased estimate of sample covariance (store in L though)*/
    for (i=0;i<N;i++)
    {
        for (j=0;j<dim;j++)
        {
            for (k=0;k<dim;k++)
            {
                L[j*dim + k] += weights[i]*(theta[i*dim + j] - mu[j])
                                          *(theta[i*dim + k] - mu[k]); 
            }
        }
    }
    for (k=0;k<dim*dim;k++)
    {
        L[k] /= (weight_bar - 1.0);
    }

    /*optimal scale is 2 based on the work of Beaumont (2009) and Filippi (2013)*/
    for (k=0;k<dim*dim;k++)
    {
        L[k] *= SCALE;
    }
    /* really it is the Cholesky factorisation we need*/
    choldc(dim,L);
    return 0;
}

/** 
 * @brief proposal kernel sampler 
 * @details given kernel parameters L, and a particle \theta a new proposal 
 *          \theta* is generated.
 *
 * @param dim           dimensionality of parameter space
 * @param theta         particle from previous step
 * @param theta_prop    proposel particle update
 * @param L             proposal kernel parameters as generated by adapt_kernel
 */
int 
kernel(unsigned int dim,double *theta, double *theta_prop, double *L)
{
    double Z[dim];
    unsigned int tf;
    tf = 1;
    while (tf)
    {
        durngmvns(dim,theta,L,Z,theta_prop);
        tf = 0;
        for (int i=0;i<dim;i++)
        {
            tf = tf || (theta_prop[i] > abc_p.support[i+dim]) || (theta_prop[i] < abc_p.support[i]);
        }
    }
    return 0;
}

/** 
 * @brief proposal kernel probability density function
 * @details given kernel parameters L, a particle \theta and a new proposal 
 *          \theta* the density is evaluated pointwise.
 *
 * @param dim           dimensionality of parameter space
 * @param theta         particle from previous step
 * @param theta_prop    proposel particle update
 * @param L             proposal kernel parameters as generated by adapt_kernel
 *
 * @returns the density at point \theta* given \theta and L.
 */
double 
kernelPDF(unsigned int dim,double *theta, double *theta_prop, double *L)
{
    double x[dim];
    double y[dim];
    double z;
    double denom;
    unsigned int i;
    /* denom = sqrt(2pi)^d det(Sigma)*/ 
    denom = pow(2.0*M_PI,((double)dim));
    /* det(Sigma) = det(L)det(L^T) = det(L)^2 = prod_i^d L(i,i) */
    for (i=0;i<dim;i++)
    {
        denom *= L[i*dim + i]*L[i*dim+i];
    }

    for (i=0;i<dim;i++)
    {
        x[i] = theta_prop[i] - theta[i];
    }
    /*solve Ly = x */
    cholfs(dim, L, y, x);
    /* z = y^T y*/
    z = 0.0;
    for(i=0;i<dim;i++)
    {
        z += y[i]*y[i];
    }
    return exp(-0.5*z)/sqrt(denom);
}

/**
 * @brief non-linear diffusion function D(C) for continuum reaction-diffusion 
 *        model
 *
 * @param c     array of density values to evaluate D() at
 * @param n     number of density points
 * @param theta model parameters
 * @param Dc    array to store D(c[i]) for i = 0,...,n-1
 */
void
D(double * c, int n, double * theta, double* Dc)
{
    double D_0;
    D_0 = theta[0];
    for (int i=0;i<n;i++)
    {
        Dc[i] = D_0;
    }
}

/**
 * @brief non-linear source function f(C) for continuum reaction-diffusion 
 *        model
 *
 * @param c     array of density values to evaluate f() at
 * @param n     number of density points
 * @param theta model parameters
 * @param fc    array to store f(c[i]) for i = 0,...,n-1
 */
void
S(double *c, int n, double *theta, double *fc)
{
    double lambda;
    double K;
    lambda = theta[1];
    K = theta[2];
    for (int i=0;i<n;i++)
    {
        fc[i] = lambda*c[i]*(1.0 - c[i]/ K);
    }
}

/**
 * @brief neighbourhood function for hexagonal lattice with periodic boundaries
 *
 * @param d         dimensionality of lattice
 * @param N         array of number of sites along each lattice axis
 * @param ind       index of a lattice site
 * @param Nhsize    pointer to store the number of sites that are neighbours to 
 *                  site ind
 * @param hex       array of size indices that are neighbours to site ind
 */
void
hexNh(int d, int *N, int ind, int *Nhsize, int *hex)
{
    int Nx = N[0];
    int Ny = N[1];
    int offx_oddy[6] = {0,-1,0,1,1,1};
    int offx_eveny[6] = {-1,-1,-1,0,1,0};
    int offy[6] = {-1,0,1,1,0,-1};
    
    /* get 2d index*/
    int j = ind / Nx;
    int i = ind % Nx;

    *Nhsize = 6;
    /*implementing periodic boundary*/
    if (j%2 == 0)
    {
        for (int k=0;k<*Nhsize;k++)
        {   
            hex[k] = ((j+offy[k]+Ny)%Ny)*Nx + (i+offx_eveny[k]+Nx)%Nx;
        }
    }
    else
    {
        for (int k=0;k<*Nhsize;k++)
        {   
            hex[k] = ((j+offy[k]+Ny)%Ny)*Nx + (i+offx_oddy[k]+Nx)%Nx;
        }
    }
}

/** 
 * @brief motility function
 *
 * @param Cavg      local density
 * @param params     model parameters
 *
 * @returns the probability of a successful motility event
 */
double g(double Cavg, double *params)
{
    double Pm = params[0]*4.0; 
    return Pm; /*leads to linear diffusion in continuum limit*/
}

/** 
 * @brief crowding function
 *
 * @param Cavg      local density
 * @param params     model parameters
 *
 * @returns the probability of a successful proliferation event
 */
double f(double Cavg, double *params)
{
    double Pp = params[1];
    double K = params[2];
    return Pp*(1.0 - Cavg/K); /*leads to logistic growth in continuum limit*/
    
}

/**
 * @brief forwards simulation function of the data generation process.
 * @details Numerically solves the PDE for the continuum model
 *
 * @param sim unused here for compatilibity with other codes
 * @param theta parameter values to use for simulation
 * @param data_s pointer to data structure to store simulated data
 */
int
simulate_PDE(void *sim, double *theta, Dataset *data_s)
{
    int R = 0; /* the number of gridpoints to be placed between data points*/ 
    int Nx;
    double L,T; /*from data also?*/
    int Nt; /*currently predetermined*/
    double * C_s;
    double * C0;
    double * C_s_f;
    double * C0_f;
    double *Ti;
    double *Xi;
    int nt;
    int nx;

    /* observation times connected with real data.*/
    Ti = (double*)data.fields[0].data_array;
    nt = (int)data.fields[0].numRows;
    Xi = (double*)data.fields[1].data_array;
    nx = (int)data.fields[1].numCols;
    C0 = (double *)data.fields[2].data_array;
    C_s = (double *)data_s->fields[3].data_array;
   
    Nx = nx + R*(nx -1);
    /* need to choose Nt... we could use dtD_0 < dx^2 as a basis */
    /* for now we just pick something that is fine (possibly overkill)*/
    Nt = 5000;
    C0_f = (double *)malloc(Nx*sizeof(double));
    C_s_f = (double *)malloc(Nx*Nt*sizeof(double));

    /* linear interpolation of initial data as the initial condition */
    for (int i=1;i<nx;i++)
    {
        /* Picture: */
        /* data point      i-1                           i        */
        /*            ...---O----------------------------O---...  */
        /* mesh points (i-1)*R  (i-1)R+1 ... (i-1)R+R-1  i*R      */
        /*            ...---O-------O---...------O-------O---...  */
        /* weights a_j      0      1/R        (R-1)/R    1        */

        double C_l,C_u;
        C_l = C0[i-1];
        C_u = C0[i];
        for (int j=0;j<=R+1;j++)
        {
            double alpha;
            alpha = ((double)j)/((double)(R + 1));
            C0_f[(i-1)*R + i-1 + j] = C_l*(1-alpha) + C_u*(alpha); 
        }
    }

    T = Ti[nt-1];
    L = Xi[nx-1]; 
    /*solve using BTCS with fixed-point iterations and adaptive time stepping*/
    dbtcsfpecs(L,T,nt,Ti,theta,C0_f,&D,&S,Nx,Nt,1e-6,1e-6,30,C_s_f);
    
    /*by construction, data points are nodes in the mesh*/
    for (int j=0;j<nt;j++)
    {
        for(int i=0;i<nx;i++)
        {
            C_s[j*nx + i] = C_s_f[j*Nx + i*(1+R)];
        }
    }
    free(C0_f);
    free(C_s_f);
    approx_sim_counter++;
    return 0;
}

/**
 * @brief forwards simulation function of the data generation process.
 * @details Stochastic simulation of lattice-based discrete random walk model
 *
 * @param sim unused here for compatilibity with other codes
 * @param theta parameter values to use for simulation
 * @param data_s pointer to data structure to store simulated data
 */
int simulate_DRW(void *sim,double * theta, Dataset * data_s)
{
    unsigned int m,nt,nx;
    double *C_r,*C0, *C, *C0_d;
    double c0;;
    double *Ti, *Xi; 
    int *dims;
    int N[2];


    /* observation times connected with real data.*/
    Ti = (double*)data.fields[0].data_array;
    nt = (int)data.fields[0].numRows;
    Xi = (double*)data.fields[1].data_array;
    nx = (int)data.fields[1].numCols;
    C0_d = (double *)data.fields[2].data_array;
    C = (double *)data_s->fields[3].data_array;
   
    m = 3; /*params are D,lambda,K */
   
    N[0] = I;
    N[1] = nx;

    c0 = 0;
    for (int i=0;i<nx;i++)
    {
        c0 += C0_d[i];
    }
    c0 /= (double)nx;

    /*initialise lattice and initial occupacies*/
    C0 = (double*) malloc(N[0]*N[1]*sizeof(double));

    dims = (int*)malloc(N[0]*N[1]*sizeof(int));
    for (int i =0;i<N[0]*N[1];i++)
    {
        double u;
        u = durngus(0,1);
        C0[i] =  (SSAL_real_t)(u <= c0);
        if (C0_d[i/N[0]] == 0)
        {
            C0[i] = 0;
        }
        dims[i] = i; /*observe all sites*/
    }

    C_r = (double*)malloc(N[0]*N[1]*nt*sizeof(double));
    memset((void*)C_r,0,N[0]*N[1]*nt*sizeof(double));
    memset((void*)C,0,nt*sizeof(double));

    /*simulate stochastic realisations*/
    dalrws(2,N,&hexNh,6,nt,Ti,theta,C0,&g,&f,N[0]*N[1],dims,1.0,C_r);
   
    /*compute spatial profile*/
    for (int j=0;j<N[1];j++)
    {
        for (int ti=0;ti<nt;ti++)
        {
            C[ti*nx + j] = 0.0; 
            for (int i=0;i<N[0];i++)
            {
                C[ti*nx + j] += C_r[(j*I + i)*nt + ti];
            }
            C[ti*nx + j] /= (double)N[0]; 
        }
    }
    
    sim_counter++;
    free(C0);
    free(dims);
    free(C_r);
    return 0;
}

/**
 * @brief Import cell count data *.csv files
 *
 * @param filename name of *.csv file
 * @parm data pointer to data structure that will store the cell density profiles
 */
void 
ImportCellCountData(char * filename, Dataset* data)
{
    FILE *fp;
    char chr;
    int numCols,numRows;
    double *xi;
    double *ti;
    double *c0;
    double *c;
    double *c_std;
    double *buffer;
    char temp[125];
    fp = fopen(filename,"r");
    numCols = 0;
    numRows = 0;
    while(!feof(fp))
    {
        chr = fgetc(fp);
        numCols += (chr == ' ' && numRows == 0);
        numRows += (chr == '\n');
    }
    numCols++;
    rewind(fp);
    buffer = (double*)malloc(numRows*numCols*sizeof(double));
    for (int j=0;j<numRows;j++)
    {
        fscanf(fp,"%lf",buffer + j*numCols);
        for (int i=1;i<numCols;i++)
        {
            fscanf(fp," %lf",buffer +j*numCols + i);
        }
        fscanf(fp,"\n");
    }
    fclose(fp);
    
    data->numFields = 4; /*time-axis, space-axis, initial condition, time-space counts*/
    data->fields = (field *)malloc(data->numFields*sizeof(field));
    /* time-axis*/
    data->fields[0].numRows = numCols-3;;
    data->fields[0].numCols = 1;
    data->fields[0].type = REAL64_DATA;
    data->fields[0].numBytes = (data->fields[0].numRows)*sizeof(double);
    data->fields[0].data_array = malloc(data->fields[0].numBytes);
    /* space-axis*/
    data->fields[1].numRows = 1;
    data->fields[1].numCols = numRows-1;
    data->fields[1].type = REAL64_DATA;
    data->fields[1].numBytes = (data->fields[1].numCols)*sizeof(double);
    data->fields[1].data_array = malloc(data->fields[1].numBytes);
    /* initial condition */
    data->fields[2].numRows = 1;
    data->fields[2].numCols = numRows-1;
    data->fields[2].type = REAL64_DATA;
    data->fields[2].numBytes = (data->fields[2].numCols)*sizeof(double);
    data->fields[2].data_array = malloc(data->fields[2].numBytes);
    /* cell count data*/
    data->fields[3].numRows = numCols-3;
    data->fields[3].numCols = numRows-1;
    data->fields[3].type = REAL64_DATA;
    data->fields[3].numBytes = (data->fields[3].numRows)*(data->fields[3].numCols)*sizeof(double);
    data->fields[3].data_array = malloc(data->fields[3].numBytes);

    ti = (double*)data->fields[0].data_array;
    for (int i=0;i<data->fields[0].numRows;i++)
    {
        ti[i] = buffer[i+3];            
    }
    xi = (double*)data->fields[1].data_array;
    for (int i=0;i<data->fields[1].numCols;i++)
    {
        xi[i] = buffer[(i+1)*(numCols)+1];            
    }
    c0 = (double*)data->fields[2].data_array;
    for (int i=0;i<data->fields[2].numCols;i++)
    {
        c0[i] = buffer[(i+1)*(numCols)+2];            
    }
    c = (double*)data->fields[3].data_array;
    for (int j=0;j<data->fields[3].numRows;j++)
    {
        for (int i=0;i<data->fields[3].numCols;i++)
        {
            c[j*(data->fields[3].numCols) + i] = buffer[(i+1)*numCols + j+3];
        }
    }
    free(buffer);
    /*shift spatial domain from [L,U] to [0,U-L]*/
    for (int i=1;i<data->fields[1].numCols;i++)
    {
        xi[i] = xi[i] - xi[0];
    }
    xi[0] = 0.0;
}

/**
 * Program entry point
 */
int 
main(int argc, char ** argv)
{
    double *theta_approx,*weights_approx;
    double *theta,*weights;
    clock_t start_t, end_t;
    double time;
    char * filename;
    int m = 3;
    double s;
    unsigned int N_particles;
    
    if (argc  < (7 + 2*m))
    {
        fprintf(stderr,"Usage: %s filename N s esp T I [sl1,sl2,...slm,su1,su2,sum] \n",argv[0]);
        exit(1);
    }
    else
    {
        filename = argv[1];
        /*set up ABC PC SMC params*/

        /* we need aabc_p = abc_p except for the simulation function*/
        /* number of particles*/
        N_particles = (unsigned int)atoi(argv[2]);
        s = (double)atof(argv[3]);
       
        /*N = sN_exact + (1-s)N_approx*/
        abc_p.nacc = (unsigned int)ceil(s*((double)N_particles));
        aabc_p.nacc = N_particles - abc_p.nacc;
        abc_p.nmax = 0;
        aabc_p.nmax = abc_p.nmax;
        
        /* final target epsilon */
        abc_p.eps = (double)atof(argv[4]);
        aabc_p.eps = abc_p.eps ;
        
        /*set number of target distributions*/
        smc_p.T = (unsigned int)atoi(argv[5]);
        
        /* @todo sequence is geometric, but should also consider adaptive*/
        smc_p.eps_t = (double*)malloc((smc_p.T)*sizeof(double));
        smc_p.eps_t[smc_p.T-1] = abc_p.eps;
        for (int t=1;t<smc_p.T;t++)
        {
            smc_p.eps_t[smc_p.T-1-t] = 2.0*(smc_p.eps_t[smc_p.T - t]);
        }
        for (int t=0;t<smc_p.T;t++)
        {
            fprintf(stderr,"eps_t[%d] = %lf\n",t,smc_p.eps_t[t]);
        }
        I = (int)atoi(argv[6]);
        
        /*fixed number of parameters*/
        abc_p.k = m; /*D, lambda, K*/
        aabc_p.k = abc_p.k;
        abc_p.support = (double *)malloc(2*abc_p.k*sizeof(double));
        aabc_p.support = (double *)malloc(2*aabc_p.k*sizeof(double));
        for (int k=0;k<abc_p.k*2;k++)
        {
            abc_p.support[k] = (double)atof(argv[7+k]);
        }
        memcpy(aabc_p.support, abc_p.support,2*abc_p.k*sizeof(double));
        abc_p.sim = NULL;
        aabc_p.sim = abc_p.sim;
        abc_p.rho = &rho;
        aabc_p.rho = abc_p.rho;
        abc_p.p = &prior;
        aabc_p. p = abc_p.p;
        abc_p.pd = &priorPDF;
        aabc_p.pd = abc_p.pd;
        abc_p.s = &simulate_DRW;
        aabc_p.s = &simulate_PDE; 
        smc_p.E = ((double)(N_particles)); /* that is, always resample*/
        /*using adaptive kernels*/
        smc_p.q_params = (double *)malloc(abc_p.k*abc_p.k*sizeof(double));
        smc_p.q_adpt = &kernel;
        smc_p.qd_adpt = &kernelPDF;
        smc_p.adpt = &adapt_kernel;
    }
    
    /* import data*/
    ImportCellCountData(filename,&data);
    
    /* Sanity check: print data summary */
    {
        double *x,*t, *c, *c_std,*c0;
        int nx,nt;
        /* get pointers to data arrays*/
        nt = data.fields[0].numRows;
        nx = data.fields[1].numCols;
        t = (double *)data.fields[0].data_array;
        x = (double *)data.fields[1].data_array;
        c0 = (double *)data.fields[2].data_array;
        c = (double *)data.fields[3].data_array;
        
        fprintf(stderr,"Dataset Information:\n");
        fprintf(stderr,"--------------------\n");
        fprintf(stderr,"Filename: %s\n",filename);
        fprintf(stderr,"# nodes: %d\n",nx);
        fprintf(stderr,"# timesteps: %d\n",nt);
        fprintf(stderr,"Spatial extent: %lf to %lf\n",x[0],x[nx-1]);
        fprintf(stderr,"Temporal extent: %f to %f\n",t[0],t[nt-1]);
        fprintf(stderr,"X = %f %f ... %f %f %f...%f %f\n",
                 x[0],x[1],x[nx/2 -1], x[nx/2], x[nx/2 +1], x[nx -2], x[nx -1]);
        fprintf(stderr,"T=00.000000 : %f %f ... %f %f %f...%f %f\n", 
                 c0[0], c0[1], c0[nx/2 -1], c0[nx/2], c0[nx/2 +1], c0[nx -2], 
                 c0[nx -1]);
        for (int i=0;i<nt;i++)
        {
            fprintf(stderr,"T=%f : %f %f ... %f %f %f...%f %f\n",
                   t[i],c[i*nx],c[i*nx + 1],c[i*nx + nx/2 -1], c[i*nx + nx/2],
                   c[i*nx + nx/2 +1],c[i*nx + nx -2],c[i*nx +nx -1]);
        }

        for (int i=0;i<nx;i++)
        {
            /* check that any sample of with be K > c0*/
            if (abc_p.support[2] <= c0[i])
            {
                fprintf(stderr,"Invalid Support for K, ensure C(0) < K for any K ~ p(K).\n C(0) = %lg, p(K) = U(%lg,%lg).\n",c0[i],abc_p.support[2],abc_p.support[5]);
                exit(1);
            }
        }
    }
       
    /*initialise our RNG library*/
    SSAL_Initialise(argc,argv);

    /*allocate output array*/
    theta_approx = (double *)malloc(aabc_p.nacc*aabc_p.k*sizeof(double));
    weights_approx = (double *)malloc(aabc_p.nacc*sizeof(double));
    theta = (double *)malloc(N_particles*abc_p.k*sizeof(double));
    weights = (double *)malloc(N_particles*sizeof(double));

    approx_sim_counter = 0; /*for performance metric*/
    sim_counter = 0; /*for performance metric*/

    /*generate posterior samples using MM-SMC-ABC*/
    start_t = clock();
    dabcammsmc(aabc_p,abc_p,smc_p,&data,theta_approx,weights_approx,NULL,theta,weights,NULL);
    end_t = clock();

    time = ((double)(end_t - start_t))/((double)CLOCKS_PER_SEC);
    
    /*write output*/
    fprintf(stdout,"\"Particle\",\"D\",\"lambda\",\"K\",\"weights\",\"SEC\",\"NACC\",\"NASIMS\",\"NSIMS\"\n");
    for (unsigned int i=0;i<N_particles;i++)
    {
        fprintf(stdout,"%u,%g,%g,%g,%g,%g,%u,%u,%u\n",i,theta[i*abc_p.k],theta[i*abc_p.k+1],theta[i*abc_p.k+2],weights[i],time,abc_p.nacc,approx_sim_counter,sim_counter);
    }

    return 0;
}

